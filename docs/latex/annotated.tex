\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{structmaier__saupe__constants_1_1backend}{maier\+\_\+saupe\+\_\+constants\+::backend$<$ space\+\_\+dim $>$}} }{\pageref{structmaier__saupe__constants_1_1backend}}{}
\item\contentsline{section}{\mbox{\hyperlink{structmaier__saupe__constants_1_1backend_3_012_01_4}{maier\+\_\+saupe\+\_\+constants\+::backend$<$ 2 $>$}} }{\pageref{structmaier__saupe__constants_1_1backend_3_012_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{structmaier__saupe__constants_1_1backend_3_013_01_4}{maier\+\_\+saupe\+\_\+constants\+::backend$<$ 3 $>$}} }{\pageref{structmaier__saupe__constants_1_1backend_3_013_01_4}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBoundaryValues}{Boundary\+Values$<$ dim $>$}} }{\pageref{classBoundaryValues}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBoundaryValuesInterface}{Boundary\+Values\+Interface}} }{\pageref{classBoundaryValuesInterface}}{}
\item\contentsline{section}{\mbox{\hyperlink{classfunctions_1_1ConfigurablePrototype}{functions\+::\+Configurable\+Prototype}} }{\pageref{classfunctions_1_1ConfigurablePrototype}}{}
\item\contentsline{section}{\mbox{\hyperlink{classdata__class}{data\+\_\+class}} }{\pageref{classdata__class}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDataToFe}{Data\+To\+Fe$<$ dim $>$}} }{\pageref{classDataToFe}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDefectConfiguration}{Defect\+Configuration$<$ dim $>$}} }{\pageref{classDefectConfiguration}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDirectorPostprocessor}{Director\+Postprocessor$<$ dim $>$}} }{\pageref{classDirectorPostprocessor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classEvaluateFEObject}{Evaluate\+F\+E\+Object$<$ dim $>$}} }{\pageref{classEvaluateFEObject}}{}
\item\contentsline{section}{\mbox{\hyperlink{classfactory_1_1Factory}{factory\+::\+Factory$<$ Prototype, Prototype\+Ptr, Prototype\+Maker\+Args $>$}} }{\pageref{classfactory_1_1Factory}}{}
\item\contentsline{section}{\mbox{\hyperlink{classfunctions_1_1FunctionPrototype}{functions\+::\+Function\+Prototype}} }{\pageref{classfunctions_1_1FunctionPrototype}}{}
\item\contentsline{section}{\mbox{\hyperlink{classGaussianDistribution}{Gaussian\+Distribution$<$ dim $>$}} }{\pageref{classGaussianDistribution}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIsoSteadyState}{Iso\+Steady\+State$<$ dim, order $>$}} }{\pageref{classIsoSteadyState}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIsoTimeDependent}{Iso\+Time\+Dependent$<$ dim, order $>$}} }{\pageref{classIsoTimeDependent}}{}
\item\contentsline{section}{\mbox{\hyperlink{structLagrangeGPUWrapper_1_1KernelParams}{Lagrange\+G\+P\+U\+Wrapper$<$ T, order, vec\+\_\+dim $>$\+::\+Kernel\+Params}} }{\pageref{structLagrangeGPUWrapper_1_1KernelParams}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLagrangeGPUWrapper}{Lagrange\+G\+P\+U\+Wrapper$<$ T, order, vec\+\_\+dim $>$}} }{\pageref{classLagrangeGPUWrapper}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLagrangeMultiplier}{Lagrange\+Multiplier$<$ order, space\+\_\+dim $>$}} \\*Takes in a $Q$-\/tensor, outputs corresponding $\Lambda$ value using the Newton-\/\+Rhapson method, where $\Lambda$ is given by\+: }{\pageref{classLagrangeMultiplier}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLagrangeMultiplierGPU}{Lagrange\+Multiplier\+G\+P\+U$<$ T, order, vec\+\_\+dim $>$}} \\*This class is called within a kernel and, given a global pointer to Lebedev coordinates and weights, does everything necessary to invert a single Q-\/vector }{\pageref{classLagrangeMultiplierGPU}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLdGIsoSteadyState}{Ld\+G\+Iso\+Steady\+State$<$ dim $>$}} }{\pageref{classLdGIsoSteadyState}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLinearInterpolation}{Linear\+Interpolation$<$ dim $>$}} }{\pageref{classLinearInterpolation}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLUMatrix}{L\+U\+Matrix$<$ T, N $>$}} \\*Identical class to \mbox{\hyperlink{classLUMatrixGPU}{L\+U\+Matrix\+G\+PU}}, except this class is a pure C++ class (rather than a Cuda class) so that it only runs on the C\+PU. See \mbox{\hyperlink{classLUMatrixGPU}{L\+U\+Matrix\+G\+PU}} for more detailed documentation and a usage example }{\pageref{classLUMatrix}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLUMatrixGPU}{L\+U\+Matrix\+G\+P\+U$<$ T, N $>$}} \\*Holds a fixed-\/size NxN matrix which can live on either the device or host side. Has methods to LU decompose, as well as solve a matrix equation given some input vector }{\pageref{classLUMatrixGPU}}{}
\item\contentsline{section}{\mbox{\hyperlink{classfoo_1_1NoTemplate}{foo\+::\+No\+Template}} }{\pageref{classfoo_1_1NoTemplate}}{}
\item\contentsline{section}{\mbox{\hyperlink{classplot__gaussian}{plot\+\_\+gaussian$<$ dim $>$}} }{\pageref{classplot__gaussian}}{}
\item\contentsline{section}{\mbox{\hyperlink{classplot__uniaxial__nematic}{plot\+\_\+uniaxial\+\_\+nematic$<$ dim $>$}} }{\pageref{classplot__uniaxial__nematic}}{}
\item\contentsline{section}{\mbox{\hyperlink{classPlusHalfDefect}{Plus\+Half\+Defect$<$ dim $>$}} }{\pageref{classPlusHalfDefect}}{}
\item\contentsline{section}{\mbox{\hyperlink{classPoissonSolver}{Poisson\+Solver$<$ dim $>$}} }{\pageref{classPoissonSolver}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSValuePostprocessor}{S\+Value\+Postprocessor$<$ dim $>$}} }{\pageref{classSValuePostprocessor}}{}
\item\contentsline{section}{\mbox{\hyperlink{classfoo_1_1Template}{foo\+::\+Template$<$ N $>$}} }{\pageref{classfoo_1_1Template}}{}
\item\contentsline{section}{\mbox{\hyperlink{classfoo_1_1TestConfig}{foo\+::\+Test\+Config}} }{\pageref{classfoo_1_1TestConfig}}{}
\item\contentsline{section}{\mbox{\hyperlink{classTestFunction}{Test\+Function$<$ dim $>$}} }{\pageref{classTestFunction}}{}
\item\contentsline{section}{\mbox{\hyperlink{classUniformConfiguration}{Uniform\+Configuration$<$ dim $>$}} }{\pageref{classUniformConfiguration}}{}
\end{DoxyCompactList}
