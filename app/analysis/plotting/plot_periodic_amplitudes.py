import argparse
import os

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib as mpl

mpl.rcParams['figure.dpi'] = 300

plt.style.use('science')

def get_commandline_args():


    description = ("Plot amplitudes from periodic configuration from csv files"
                   " generated by Paraview 'Plot selection over time'")
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('--data_folder', dest='data_folder',
                        help='folder where defect location data lives')
    parser.add_argument('--spreadsheet_names',
                        dest='spreadsheet_names',
                        nargs='*',
                        help='list of names of csv files where amplitude data is')
    parser.add_argument('--output_folder',
                        dest='output_folder',
                        default=None,
                        help='folder that output file will be written to')
    parser.add_argument('--plot_filename',
                        dest='plot_filename',
                        help='filename of amplitude plot')
    parser.add_argument('--log_plot_filename',
                        dest='log_plot_filename',
                        help='filename of log plot of amplitudes')

    parser.add_argument('--time_key',
                        dest='time_key',
                        default='Time',
                        help='key in csv file corresponding to time data')
    parser.add_argument('--amplitude_key',
                        dest='amplitude_key',
                        default='avg(Q1)',
                        help='key in csv file corresopnding to amplitude data')

    parser.add_argument('--dt_vals',
                        dest='dt_vals',
                        type=float,
                        nargs='*',
                        help='values for dt corresponding to spreadsheet names')

    parser.add_argument('--alpha',
                        dest='alpha',
                        type=float,
                        help='Maier-Saupe mean-field coupling constant')
    parser.add_argument('--dLambda_dQ',
                        dest='dLambda_dQ',
                        type=float,
                        help='Numerical derivative of singular potential')
    parser.add_argument('--k',
                        dest='k',
                        type=float,
                        help='Wave number of perturbation')

    parser.add_argument('--time_discretization',
                        dest='time_discretization',
                        choices=['convex_splitting', 'forward_euler', 'semi_implicit'],
                        help='Type of time discretization')
    parser.add_argument('--theta',
                        dest='theta',
                        type=float,
                        default=1.0,
                        help='Semi-implicit scheme parameter')

    args = parser.parse_args()

    spreadsheet_names = []
    for spreadsheet_name in args.spreadsheet_names:
        spreadsheet_names.append( os.path.join(args.data_folder, 
                                               spreadsheet_name) )

    output_folder = None
    if not args.output_folder:
        output_folder = args.data_folder
    else:
        output_folder = args.output_folder

    output_filename = os.path.join(output_folder, args.plot_filename)
    log_output_filename = os.path.join(output_folder, args.log_plot_filename)

    return (spreadsheet_names, output_filename, log_output_filename,
            args.time_key, args.amplitude_key, args.dt_vals, 
            args.alpha, args.dLambda_dQ, args.k,
            args.time_discretization, args.theta)



def eps_coeff(time_discretization, alpha, dLambda_dQ, k, dt, theta=0):

    if (time_discretization == 'convex_splitting'):
        tau = -(alpha - dLambda_dQ - k**2) / (1 + dt * dLambda_dQ + dt * k**2)
        return (1 - tau * dt)
    elif (time_discretization == 'forward_euler'):
        tau = -(alpha - dLambda_dQ - k**2)
        return (1 - tau * dt)
    elif (time_discretization == 'semi_implicit'):
        tau = -(alpha - dLambda_dQ - k**2)
        return (1 - theta * dt * tau) / (1 + (1 - theta) * dt * tau)



def main():

    (spreadsheet_names, output_filename, log_output_filename,
     time_key, amplitude_key, dt_vals,
     alpha, dLambda_dQ, k,
     time_discretization, theta) = get_commandline_args()

    tau = -(alpha - dLambda_dQ - k**2)

    # Each entry in this list corresponds to a simulation run
    data = []
    for spreadsheet_name in spreadsheet_names:
        data.append( pd.read_csv(spreadsheet_name) )

    t = []
    n = []
    amplitudes = []
    amplitudes_true = []
    for datum, dt in zip(data, dt_vals):
        eps_coeff_val = eps_coeff(time_discretization, 
                                  alpha, 
                                  dLambda_dQ, 
                                  k, 
                                  dt, 
                                  theta)

        current_t = np.array(datum[time_key].values * dt)
        current_n = np.array(datum[time_key].values)
        current_amplitude = np.array(datum[amplitude_key].values)

        t.append(current_t)
        n.append(current_n)
        amplitudes.append(current_amplitude)

        amplitudes_true.append(current_amplitude[0] 
                               * eps_coeff_val**current_n)

    t_lims = (t[0][0], t[0][-1])
    t_ref = np.linspace(t_lims[0], t_lims[1], num=1000)
    initial_amplitude = amplitudes[-1][0]
    amplitude_ref = initial_amplitude * np.exp(-tau * t_ref)

    fig, ax = plt.subplots()
    for time, amplitude, dt, amplitude_true in zip(t, amplitudes, dt_vals, amplitudes_true):
        ax.plot(time, amplitude, label='dt = {}'.format(dt))
        ax.plot(time, amplitude_true, label=r'$\Delta t$ = {}'.format(dt), ls='--')

    ax.plot(t_ref, amplitude_ref, label='analytic estimate')

    ax.set_title(r'$Q_1$ component amplitude decay')
    ax.set_xlabel('time')
    ax.set_ylabel(r'$Q_1$ component amplitude')
    ax.legend()
    fig.tight_layout()

    fig.savefig(output_filename)
    
    fig, ax = plt.subplots()
    for time, amplitude, dt, amplitude_true in zip(t, amplitudes, dt_vals, amplitudes_true):
        ax.plot(time, np.log(amplitude), label='dt = {}'.format(dt))
        ax.plot(time, np.log(amplitude_true), label=r'$\Delta t$ = {}'.format(dt), ls='--')

    ax.plot(t_ref, np.log(amplitude_ref), label='analytic estimate')

    ax.set_title(r'$Q_1$ component amplitude decay (log)')
    ax.set_xlabel('time')
    ax.set_ylabel(r'$Q_1$ component amplitude (log)')
    ax.legend()
    fig.tight_layout()

    fig.savefig(log_output_filename)

    plt.show()


if __name__ == '__main__':
    main()
